@article{reflect-random,
  author = {Goldstein, Harrison and Frohlich, Samantha and Wang, Meng and Pierce, Benjamin C.},
  title = {Reflecting on Random Generation},
  year = {2023},
  issue_date = {August 2023},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {7},
  number = {ICFP},
  url = {https://doi.org/10.1145/3607842},
  doi = {10.1145/3607842},
  abstract = {Expert users of property-based testing often labor to craft random generators that encode detailed knowledge about what it means for a test input to be valid and interesting. Fortunately, the fruits of this labor can also be put to other uses. In the bidirectional programming literature, for example, generators have been repurposed as validity checkers, while Python's Hypothesis library uses the same structures for shrinking and mutating test inputs.

  To unify and generalize these uses and many others, we propose reflective generators, a new foundation for random data generators that can "reflect" on an input value to calculate the random choices that could have been made to produce it. Reflective generators combine ideas from two existing abstractions: free generators and partial monadic profunctors. They can be used to implement and enhance the aforementioned shrinking and mutation algorithms, generalizing them to work for any values that can be produced by the generator, not just ones for which a trace of the generator's execution is available. Beyond shrinking and mutation, reflective generators generalize a published algorithm for example-based generation, and they can also be used as checkers, partial value completers, and other kinds of test data producers.},
  journal = {Proc. ACM Program. Lang.},
  month = aug,
  articleno = {200},
  numpages = {34},
  keywords = {bidirectional programming, property-based testing, random generation}
}

@InProceedings{monadic-profunctors,
  author="Xia, Li-yao and Orchard, Dominic and Wang, Meng",
  editor="Caires, Lu{\'i}s",
  title="Composing Bidirectional Programs Monadically",
  booktitle="Programming Languages and Systems",
  year="2019",
  publisher="Springer International Publishing",
  address="Cham",
  pages="147--175",
  abstract="Software frequently converts data from one representation to another and vice versa. Na{\"i}vely specifying both conversion directions separately is error prone and introduces conceptual duplication. Instead, bidirectional programming techniques allow programs to be written which can be interpreted in both directions. However, these techniques often employ unfamiliar programming idioms via restricted, specialised combinator libraries. Instead, we introduce a framework for composing bidirectional programs monadically, enabling bidirectional programming with familiar abstractions in functional languages such as Haskell. We demonstrate the generality of our approach applied to parsers/printers, lenses, and generators/predicates. We show how to leverage compositionality and equational reasoning for the verification of round-tripping properties for such monadic bidirectional programs.",
  isbn="978-3-030-17184-1"
}

@article{functional-unparsing,
  title={Functional unparsing},
  volume={8},
  DOI={10.1017/S0956796898003104},
  number={6},
  journal={Journal of Functional Programming},
  author={Danvy, Olivier},
  year={1998},
  pages={621–625}
}

@article{functional-ununparsing,
  title={Functional un|unparsing},
  author={Asai, Kenichi and Kiselyov, Oleg and Shan, Chung-chieh},
  journal={Higher-Order and Symbolic Computation},
  year={2011},
  doi={10.1007/s10990-012-9087-2},
  url={https://doi.org/10.1007/s10990-012-9087-2},
  abstract={Danvy’s functional unparsing problem (Danvy in J. Funct. Program. 8(6), 621–625, 1998) is to implement a type-safe ‘printf’ function, which converts a sequence of heterogeneous arguments to a string according to a given format. The dual problem is to implement a type-safe ‘scanf’ function, which extracts a sequence of heterogeneous arguments from a string by interpreting (Friedman and Wand in LFP, pp. 348–355, 1984 and in Essentials of Programming Languages, MIT Press, 2008) the same format as an equally heterogeneous sequence of patterns that binds zero or more variables. We derive multiple solutions to both problems (Wand in J. ACM 27(1), 164–180, 1980) from their formal specifications (Wand in Theor. Comput. Sci. 20(1), 3–32, 1982).}
}

@InProceedings{polymorphic-conts,
  author="Asai, Kenichi and Kameyama, Yukiyoshi",
  editor="Shao, Zhong",
  title="Polymorphic Delimited Continuations",
  booktitle="Programming Languages and Systems",
  year="2007",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="239--254",
  abstract="This paper presents a polymorphic type system for a language with delimited control operators, shift and reset. Based on the monomorphic type system by Danvy and Filinski, the proposed type system allows pure expressions to be polymorphic. Thanks to the explicit presence of answer types, our type system satisfies various important properties, including strong type soundness, existence of principal types and an inference algorithm, and strong normalization. Relationship to CPS translation as well as extensions to impredicative polymorphism are also discussed. These technical results establish the foundation of polymorphic delimited continuations.",
  isbn="978-3-540-76637-7"
}

@InProceedings{substructural-delimcc,
  author="Kiselyov, Oleg and Shan, Chung-chieh",
  editor="Della Rocca, Simona Ronchi",
  title="A Substructural Type System for Delimited Continuations",
  booktitle="Typed Lambda Calculi and Applications",
  year="2007",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="223--239",
  abstract="We propose type systems that abstractly interpret small-step rather than big-step operational semantics. We treat an expression or evaluation context as a structure in a linear logic with hypothetical reasoning. Evaluation order is not only regulated by familiar focusing rules in the operational semantics, but also expressed by structural rules in the type system, so the types track control flow more closely. Binding and evaluation contexts are related, but the latter are linear.",
  isbn="978-3-540-73228-0"
}

@InProceedings{shift0,
  author="Materzok, Marek and Biernacki, Dariusz",
  editor="Jhala, Ranjit and Igarashi, Atsushi",
  title="A Dynamic Interpretation of the CPS Hierarchy",
  booktitle="Programming Languages and Systems",
  year="2012",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="296--311",
  abstract="The CPS hierarchy of control operators shifti/resetiof Danvy and Filinski is a natural generalization of the shift and reset static control operators that allow for abstracting delimited control in a structured and CPS-guided manner. In this article we show that a dynamic variant of shift/reset, known as shift0/reset0, where the discipline of static access to the stack of delimited continuations is relaxed, can fully express the CPS hierarchy. This result demonstrates the expressive power of shift0/reset0 and it offers a new perspective on practical applications of the CPS hierarchy.",
  isbn="978-3-642-35182-2"
}

@article{typed-functional-unparsing,
  title={On typing delimited continuations: three new solutions to the printf problem},
  author={Asai, Kenichi},
  journal={Higher-Order and Symbolic Computation},
  year={2009},
  abstract={In “Functional Unparsing” (J. Funct. Program. 8(6):621–625, 1998), Danvy presented a type-safe printf function using continuations and an accumulator to achieve the effect of dependent types. The key technique employed in Danvy’s solution is the non-standard use of continuations: not all of its calls are tail calls, i.e., it uses delimited continuations. Against this backdrop, we present three new solutions to the printf problem: a simpler one that also uses delimited continuations but that does not use an accumulator, and the corresponding two in direct style with the delimited-control operators, shift and reset. These two solutions are the direct-style counterparts of the two continuation-based ones. The last solution pinpoints the essence of Danvy’s solution: shift is used to change the answer type of delimited continuations. Besides providing a new application of shift and reset, the solutions in direct style raise a key issue in the typing of first-class delimited continuations and require Danvy and Filinski’s original type system. The resulting types precisely account for the behavior of printf.},
  doi={10.1007/s10990-009-9049-5},
  url={https://doi.org/10.1007/s10990-009-9049-5},
}

@inproceedings{parsec-design-patterns,
  author = {Willis, Jamie and Wu, Nicolas},
  title = {Design patterns for parser combinators (functional pearl)},
  year = {2021},
  isbn = {9781450386159},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3471874.3472984},
  doi = {10.1145/3471874.3472984},
  abstract = {Parser combinators are a popular and elegant approach for parsing in functional languages. The design and implementation of such libraries are well discussed, but having a well-designed library is only one-half of the story. In this paper we explore several reusable approaches to writing parsers in combinator style, focusing on easy to apply patterns to keep parsing code simple, separated, and maintainable.},
  booktitle = {Proceedings of the 14th ACM SIGPLAN International Symposium on Haskell},
  pages = {71–84},
  numpages = {14},
  keywords = {parser combinators},
  location = {Virtual, Republic of Korea},
  series = {Haskell 2021}
}

@article{parsley,
  author = {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
  title = {Staged selective parser combinators},
  year = {2020},
  issue_date = {August 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {ICFP},
  url = {https://doi.org/10.1145/3409002},
  doi = {10.1145/3409002},
  abstract = {Parser combinators are a middle ground between the fine control of hand-rolled parsers and the high-level almost grammar-like appearance of parsers created via parser generators. They also promote a cleaner, compositional design for parsers. Historically, however, they cannot match the performance of their counterparts.  This paper describes how to compile parser combinators into parsers of hand-written quality. This is done by leveraging the static information present in the grammar by representing it as a tree. However, in order to exploit this information, it will be necessary to drop support for monadic computation since this generates dynamic structure. Selective functors can help recover lost functionality in the absence of monads, and the parser tree can be partially evaluated with staging. This is implemented in a library called Parsley.},
  journal = {Proc. ACM Program. Lang.},
  month = aug,
  articleno = {120},
  numpages = {30},
  keywords = {combinators, meta-programming, parsers}
}

@article{pattern-combinators,
  title={Type-safe pattern combinators},
  volume={19},
  DOI={10.1017/S0956796808007089},
  number={2},
  journal={Journal of Functional Programming},
  author={RHIGER,
  MORTEN},
  year={2009},
  pages={145–156}
}

@inproceedings{10.1145/1863523.1863525,
  author = {Rendel, Tillmann and Ostermann, Klaus},
  title = {Invertible syntax descriptions: unifying parsing and pretty printing},
  year = {2010},
  isbn = {9781450302524},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1863523.1863525},
  doi = {10.1145/1863523.1863525},
  abstract = {Parsers and pretty-printers for a language are often quite similar, yet both are typically implemented separately, leading to redundancy and potential inconsistency. We propose a new interface of syntactic descriptions, with which both parser and pretty-printer can be described as a single program. Whether a syntactic description is used as a parser or as a pretty-printer is determined by the implementation of the interface. Syntactic descriptions enable programmers to describe the connection between concrete and abstract syntax once and for all, and use these descriptions for parsing or pretty-printing as needed. We also discuss the generalization of our programming technique towards an algebra of partial isomorphisms.},
  booktitle = {Proceedings of the Third ACM Haskell Symposium on Haskell},
  pages = {1–12},
  numpages = {12},
  keywords = {pretty printing, parser combinators, invertible computation, embedded domain specific languages},
  location = {Baltimore, Maryland, USA},
  series = {Haskell '10}
}

@article{partial-isomorphism,
  author = {Rendel, Tillmann and Ostermann, Klaus},
  title = {Invertible syntax descriptions: unifying parsing and pretty printing},
  year = {2010},
  issue_date = {November 2010},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {45},
  number = {11},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/2088456.1863525},
  doi = {10.1145/2088456.1863525},
  abstract = {Parsers and pretty-printers for a language are often quite similar, yet both are typically implemented separately, leading to redundancy and potential inconsistency. We propose a new interface of syntactic descriptions, with which both parser and pretty-printer can be described as a single program. Whether a syntactic description is used as a parser or as a pretty-printer is determined by the implementation of the interface. Syntactic descriptions enable programmers to describe the connection between concrete and abstract syntax once and for all, and use these descriptions for parsing or pretty-printing as needed. We also discuss the generalization of our programming technique towards an algebra of partial isomorphisms.},
  journal = {SIGPLAN Not.},
  month = sep,
  pages = {1–12},
  numpages = {12},
  keywords = {pretty printing, parser combinators, invertible computation, embedded domain specific languages}
}

@article{biparser-exact-print,
  author = {Xie, Ruifeng and Schrijvers, Tom and Hu, Zhenjiang},
  title = {Biparsers: Exact Printing for Data Synchronisation},
  year = {2025},
  issue_date = {January 2025},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {9},
  number = {POPL},
  url = {https://doi.org/10.1145/3704910},
  doi = {10.1145/3704910},
  abstract = {Parsers and printers are vital for data synchronisation between different serialisation formats. As they are tightly related, much research has been devoted to showing that both can be derived from a single definition. It, however, turns out to be challenging to extend this work with exact-printing, which recovers the original source text for the parsed data. In this paper, we propose a new approach to tackling the challenge that considers a parser-printer pair as a mechanism to synchronize the input text string with the data, and formalizes them as a bidirectional program (lens). We propose the first biparser framework to support exact-printing with non-injective parsers, provide a library of combinators for common patterns, and demonstrate its usefulness with biparsers for subsets of JSON and YAML.},
  journal = {Proc. ACM Program. Lang.},
  month = jan,
  articleno = {74},
  numpages = {27},
  keywords = {bidirectional transformations, exact-printing, lens, parser combinators}
}

@article{biyacc,
  author = {Zhu, Zirun and Ko, Hsiang-Shang and Zhang, Yongzhe and Martins, Pedro and Saraiva, Jo\~{a}o and Hu, Zhenjiang},
  title = {Unifying Parsing and Reflective Printing for Fully Disambiguated Grammars},
  year = {2020},
  issue_date = {Jul 2020},
  publisher = {Ohmsha},
  address = {JPN},
  volume = {38},
  number = {3},
  issn = {0288-3635},
  url = {https://doi.org/10.1007/s00354-019-00082-y},
  doi = {10.1007/s00354-019-00082-y},
  abstract = {Language designers usually need to implement parsers and printers. Despite being two closely related programs, in practice they are often designed separately, and then need to be revised and kept consistent as the language evolves. It will be more convenient if the parser and printer can be unified and developed in a single program, with their consistency guaranteed automatically. Furthermore, in certain scenarios (like showing compiler optimisation results to the programmer), it is desirable to have a more powerful reflective printer that, when an abstract syntax tree corresponding to a piece of program text is modified, can propagate the modification to the program text while preserving layouts, comments, and syntactic sugar. To address these needs, we propose a domain-specific language BiYacc, whose programs denote both a parser and a reflective printer for a fully disambiguated context-free grammar. BiYacc is based on the theory of bidirectional transformations, which helps to guarantee by construction that the generated pairs of parsers and reflective printers are consistent. Handling grammatical ambiguity is particularly challenging: we propose an approach based on generalised parsing and disambiguation filters, which produce all the parse results and (try to) select the only correct one in the parsing direction; the filters are carefully bidirectionalised so that they also work in the printing direction and do not break the consistency between the parsers and reflective printers. We show that BiYacc is capable of facilitating many tasks such as Pombrio and Krishnamurthi’s ‘resugaring’, simple refactoring, and language evolution.},
  journal = {New Gen. Comput.},
  month = jul,
  pages = {423–476},
  numpages = {54},
  keywords = {Reflective printing, Parsing, Domain-specific languages, Bidirectional transformations, Disambiguation filters, Asymmetric lenses}
}

@inproceedings{bigul,
  author = {Ko, Hsiang-Shang and Zan, Tao and Hu, Zhenjiang},
  title = {BiGUL: a formally verified core language for putback-based bidirectional programming},
  year = {2016},
  isbn = {9781450340977},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2847538.2847544},
  doi = {10.1145/2847538.2847544},
  abstract = {Putback-based bidirectional programming allows the programmer to write only one putback transformation, from which the unique corresponding forward transformation is derived for free. The logic of a putback transformation is more sophisticated than that of a forward transformation and does not always give rise to well-behaved bidirectional programs; this calls for more robust language design to support development of well-behaved putback transformations. In this paper, we design and implement a concise core language BiGUL for putback-based bidirectional programming to serve as a foundation for higher-level putback-based languages. BiGUL is completely formally verified in the dependently typed programming language Agda to guarantee that any putback transformation written in BiGUL is well-behaved.},
  booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
  pages = {61–72},
  numpages = {12},
  keywords = {Putback-based bidirectional transformations, dependent types, formal verification},
  location = {St. Petersburg, FL, USA},
  series = {PEPM '16}
}

@inproceedings{parameterised-isomorphism,
author = {\r{A}gren Thun\'{e}, Anders and Matsuda, Kazutaka and Wang, Meng},
title = {Reconciling Partial and Local Invertibility},
year = {2024},
isbn = {978-3-031-57266-1},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-031-57267-8_3},
doi = {10.1007/978-3-031-57267-8_3},
abstract = {Invertible programming languages specify transformations to be run in two directions, such as compression/decompression or encryption/decryption. Two key concepts in invertible programming languages are partial invertibility and local invertibility. Partial invertibility lets invertible code be parameterized by the results of non-invertible code, whereas local invertibility requires all code to be invertible. The former allows for more flexible programming, while the latter has connections to domains such as low-energy computing and quantum computing. We find that existing approaches lack a satisfying treatment of partial invertibility, leaving the connection to local invertibility unclear.In this paper, we identify four core constructs for partially invertible programming, and show how to give them a locally invertible interpretation. We show the expressiveness of the constructs by designing the functional invertible language Kalpis, and show how to give them a locally invertible semantics using the novel arrow combinator language RRARR—the key idea is viewing partial invertibility as an invertible effect. By formalizing the two systems and giving Kalpis semantics by translation to RRARR, we reconcile partial and local invertibility, solving an open problem in the field. All formal developments are mechanized in Agda.},
booktitle = {Programming Languages and Systems: 33rd European Symposium on Programming, ESOP 2024, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2024, Luxembourg City, Luxembourg, April 6–11, 2024, Proceedings, Part II},
pages = {59–89},
numpages = {31},
keywords = {Reversible computation, Arrows, Partial invertibility, Domain-specific languages},
location = {Luxembourg City, Luxembourg}
}
