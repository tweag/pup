\documentclass[sigplan,review,dvipsnames,screen,10pt]{acmart}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\citestyle{acmauthoryear}
\usepackage[capitalize, noabbrev]{cleveref}

%% Rights management information. SAMPLE value until references are given.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Functional (un)unparsing meets structured data}
\subtitle{Continuations for sums and products}

\author{Mathieu Boespflug}
\email{m@tweag.io}
% \orcid{1234-5678-9012}

\author{Arnaud Spiwack}
\email{arnaud.spiwack@tweag.io}
\orcid{0000-0002-5985-2086}
%% TODO: country is mandatory, not sure what we should write
%% TODO: this is the official way to make a shared affiliation, but it
%% doesn't look great at all.
\affiliation{%
  \institution{Tweag}
  % \city{??}
  \country{France}
}


%% If needed
% \renewcommand{\shortauthors}{Boespflug \& Spiwack}

\begin{abstract}
  Bidirectional parsers done more betterer.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% TODO: Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>00000000.0000000.0000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% TODO: Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Do, Not, Us, This, Code, Put, the, Correct, Terms, for,
  Your, Paper}

\maketitle

\section{Related work}

\begin{itemize}
\item Where it all started \cite{functional-unparsing}. See also a
  more direct link to delimited control
  \cite{typed-functional-unparsing}.
\item Pattern combinators which use continuation for flattening. Very
  similar to functional unparsing \cite{pattern-combinators}
\item Scanf in Danvy style \cite{functional-ununparsing}
\item Foundational work on deep delimited control \cite{shift0}
\item Typed accounts of delimited continuation with answer-type
  modification \cite{polymorphic-conts,substructural-delimcc}
\item Partial monadic profunctor for bidirectional parsers (and more)
  \cite{monadic-profunctors}. One lesson we can learn from this is
  that parsing is easy (in all their example one of the sides is
  easy). The difficult bit is to build a printer type which will align
  with the parser type. Before that, the notion of partial isomorphism
  was proposed \cite{partial-isomorphism}, it was a first, less
  ergonomic, step.
  \begin{itemize}
  \item Use partial monadic profunctor techniques for random
    generators \cite{reflect-random}. This paper demonstrates the
    alternative combinators, which Arnaud didn't find in the original
    partial monadic profunctor paper.
  \end{itemize}
\item Correct-by-construction biparsers used for exact printing
  \cite{biparser-exact-print}. This are arrow (or arrow-like)
  combinators. The API demonstrated in the article is in Agda, and
  combinators have proof obligations (search, \emph{e.g.} for
  \verb+AlignConsistent+). But they claim a Haskell library too. I
  don't know if the Haskell library is just as
  correct-by-construction. Parsers are parameterised by two return
  types: the type of data, and the “complement” which consists at
  least of the span/position data for exact printing (they equate this
  data/complement duality to the parser returning a lens, delightful
  stuff). It also has a pretty comprehensive related work section.
\item A biparser DSL (called \emph{BiYacc} but the relation to Yacc is
  rather tenuous) \cite{biyacc}. The technical device seems to be the
  definition of both AST and CST as inputs of a biparser. Then the
  translations between AST and CST is written in a style where it can
  be read as pattern matching left-to-right and
  right-to-left. Biparsers are compiled to lenses (the fact that
  they're lenses and not isomorphism-like structure seems important,
  why?). Not quite to combinators, though, it's a little more complex
  than that. The target is a language for lenses called
  BiGUL~\cite{bigul}. Why lenses? Because it allows to reason
  compositionaly about correctness. Whereas
  in~\cite{monadic-profunctors}, where the parser and printer are
  essentially independent, it's a little more difficult.
\item Only tangentially related
  \begin{itemize}
  \item Recent work on parser combinators
    \cite{parsley,parsec-design-patterns}.
  \item A language whose semantics is so-called parameterised
    isomorphisms~\cite{parameterised-isomorphism}. Basically, the
    language has a regular type of arrows and a type of
    isomorphism. Everything is fairly natural in there, except the
    invertible \verb+case+ expressions, which feel frankly magical,
    but aren't explained in details because they come from previous
    work (of which there seems to be plenty!).
  \end{itemize}
\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}{}

\end{document}

% LocalWords:  combinators Parsers compositionaly invertible
% LocalWords:  isomorphisms
